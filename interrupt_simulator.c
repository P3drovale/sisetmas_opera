#define _GNU_SOURCE
#include "interrupt_simulator.h"

// Tabla de Descriptores de Interrupci√≥n (IDT)
irq_descriptor_t idt[MAX_INTERRUPTS];

// Sistema de trazabilidad
trace_entry_t trace_log[MAX_TRACE_LINES];
int trace_index = 0;

// Variables globales del sistema
int system_running = 1;
int timer_counter = 0;
pthread_t timer_thread;
pthread_mutex_t idt_mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t trace_mutex = PTHREAD_MUTEX_INITIALIZER;
system_stats_t stats;

// Variables globales adicionales
log_level_t current_log_level = LOG_LEVEL_USER_ONLY;  // Por defecto, solo acciones del usuario
int show_timer_logs = 0;  // Timer logs ocultos por defecto


// Funci√≥n para obtener timestamp
void get_timestamp(char *buffer, size_t size) {
    time_t rawtime;
    struct tm *timeinfo;
    time(&rawtime);
    timeinfo = localtime(&rawtime);
    strftime(buffer, size, "%H:%M:%S", timeinfo);
}

// Funci√≥n para agregar entrada a la traza (thread-safe)
void add_trace(const char *event) {
    pthread_mutex_lock(&trace_mutex);
    get_timestamp(trace_log[trace_index].timestamp, sizeof(trace_log[trace_index].timestamp));
    strncpy(trace_log[trace_index].event, event, sizeof(trace_log[trace_index].event) - 1);
    trace_log[trace_index].event[sizeof(trace_log[trace_index].event) - 1] = '\0';
    trace_log[trace_index].irq_num = -1;
    trace_index = (trace_index + 1) % MAX_TRACE_LINES;
    pthread_mutex_unlock(&trace_mutex);
    
    printf("[%s] %s\n", trace_log[(trace_index - 1 + MAX_TRACE_LINES) % MAX_TRACE_LINES].timestamp, event);
    fflush(stdout);
}

// Funci√≥n para agregar entrada a la traza con IRQ espec√≠fico (thread-safe)
void add_trace_with_irq(const char *event, int irq_num) {
    pthread_mutex_lock(&trace_mutex);
    get_timestamp(trace_log[trace_index].timestamp, sizeof(trace_log[trace_index].timestamp));
    strncpy(trace_log[trace_index].event, event, sizeof(trace_log[trace_index].event) - 1);
    trace_log[trace_index].event[sizeof(trace_log[trace_index].event) - 1] = '\0';
    trace_log[trace_index].irq_num = irq_num;
    trace_index = (trace_index + 1) % MAX_TRACE_LINES;
    pthread_mutex_unlock(&trace_mutex);
    
    printf("[%s] %s\n", trace_log[(trace_index - 1 + MAX_TRACE_LINES) % MAX_TRACE_LINES].timestamp, event);
    fflush(stdout);
}

// Funci√≥n para logging silencioso (solo guarda en traza, no imprime)
void add_trace_silent(const char *event) {
    pthread_mutex_lock(&trace_mutex);
    get_timestamp(trace_log[trace_index].timestamp, sizeof(trace_log[trace_index].timestamp));
    strncpy(trace_log[trace_index].event, event, sizeof(trace_log[trace_index].event) - 1);
    trace_log[trace_index].event[sizeof(trace_log[trace_index].event) - 1] = '\0';
    trace_log[trace_index].irq_num = -1;
    trace_index = (trace_index + 1) % MAX_TRACE_LINES;
    pthread_mutex_unlock(&trace_mutex);
    // NO imprime nada
}

void add_trace_with_irq_silent(const char *event, int irq_num) {
    pthread_mutex_lock(&trace_mutex);
    get_timestamp(trace_log[trace_index].timestamp, sizeof(trace_log[trace_index].timestamp));
    strncpy(trace_log[trace_index].event, event, sizeof(trace_log[trace_index].event) - 1);
    trace_log[trace_index].event[sizeof(trace_log[trace_index].event) - 1] = '\0';
    trace_log[trace_index].irq_num = irq_num;
    trace_index = (trace_index + 1) % MAX_TRACE_LINES;
    pthread_mutex_unlock(&trace_mutex);
    // NO imprime nada
}

// Funci√≥n para controlar el nivel de logging
void set_log_level(log_level_t level) {
    current_log_level = level;
    const char* level_names[] = {"SILENCIOSO", "SOLO USUARIO", "VERBOSE"};
    printf("Nivel de logging cambiado a: %s\n", level_names[level]);
}

void toggle_timer_logs(void) {
    show_timer_logs = !show_timer_logs;
    printf("Logs del timer: %s\n", show_timer_logs ? "HABILITADOS" : "DESHABILITADOS");
}

// Funci√≥n de logging inteligente
void add_trace_smart(const char *event, int irq_num, int is_timer_related) {
    // Siempre guardar en la traza para el historial
    if (irq_num >= 0) {
        add_trace_with_irq_silent(event, irq_num);
    } else {
        add_trace_silent(event);
    }
    
    // Decidir si mostrar en pantalla
    int should_print = 0;
    
    switch (current_log_level) {
        case LOG_LEVEL_SILENT:
            should_print = 0;
            break;
            
        case LOG_LEVEL_USER_ONLY:
            // Solo mostrar si no es del timer, o si los logs del timer est√°n habilitados
            if (is_timer_related) {
                should_print = show_timer_logs;
            } else {
                should_print = 1;
            }
            break;
            
        case LOG_LEVEL_VERBOSE:
            should_print = 1;
            break;
    }
    
    if (should_print) {
        if (irq_num >= 0) {
            printf("[%s] [IRQ%d] %s\n", 
                   trace_log[(trace_index - 1 + MAX_TRACE_LINES) % MAX_TRACE_LINES].timestamp,
                   irq_num, event);
        } else {
            printf("[%s] %s\n", 
                   trace_log[(trace_index - 1 + MAX_TRACE_LINES) % MAX_TRACE_LINES].timestamp,
                   event);
        }
        fflush(stdout);
    }
}

// Validaci√≥n de n√∫mero de IRQ
int validate_irq_num(int irq_num) {
    return IS_VALID_IRQ(irq_num) ? SUCCESS : ERROR_INVALID_IRQ;
}

// Verificar si IRQ est√° disponible
int is_irq_available(int irq_num) {
    if (!IS_VALID_IRQ(irq_num)) return 0;
    LOCK_IDT();
    int available = (idt[irq_num].state == IRQ_STATE_FREE);
    UNLOCK_IDT();
    return available;
}

// Obtener string del estado del IRQ
const char* get_irq_state_string(irq_state_t state) {
    switch (state) {
        case IRQ_STATE_FREE: return "LIBRE";
        case IRQ_STATE_REGISTERED: return "REGISTRADO";
        case IRQ_STATE_EXECUTING: return "EJECUTANDO";
        default: return "DESCONOCIDO";
    }
}

// Inicializaci√≥n de la IDT
void init_idt() {
    LOCK_IDT();
    for (int i = 0; i < MAX_INTERRUPTS; i++) {
        idt[i].isr = NULL;
        idt[i].state = IRQ_STATE_FREE;
        idt[i].call_count = 0;
        idt[i].last_call = 0;
        idt[i].total_execution_time = 0;
        snprintf(idt[i].description, sizeof(idt[i].description), 
            "IRQ %d - Vector libre en IDT", i);
    }
    UNLOCK_IDT();
    
    add_trace("üöÄ KERNEL: Tabla de Descriptores de Interrupci√≥n (IDT) inicializada");
    add_trace("üéØ KERNEL: 16 vectores de interrupci√≥n disponibles para asignaci√≥n");
    add_trace("üîß HARDWARE: Controlador de interrupciones (PIC/APIC) configurado");
}

// Inicializaci√≥n de estad√≠sticas del sistema
void init_system_stats() {
    memset(&stats, 0, sizeof(system_stats_t));
    stats.system_start_time = time(NULL);
}

// Actualizar estad√≠sticas (thread-safe)
void update_stats(int irq_num, unsigned long execution_time) {
    static pthread_mutex_t stats_mutex = PTHREAD_MUTEX_INITIALIZER;
    
    pthread_mutex_lock(&stats_mutex);
    stats.total_interrupts++;
    
    if (irq_num == IRQ_TIMER) {
        stats.timer_interrupts++;
    } else if (irq_num == IRQ_KEYBOARD) {
        stats.keyboard_interrupts++;
    } else {
        stats.custom_interrupts++;
    }
    
    // Calcular tiempo promedio de respuesta
    if (stats.total_interrupts > 0) {
        stats.average_response_time = 
            (stats.average_response_time * (stats.total_interrupts - 1) + execution_time) / 
            stats.total_interrupts;
    }
    pthread_mutex_unlock(&stats_mutex);
}

// Registro de ISR en la IDT
int register_isr(int irq_num, void (*isr_function)(int), const char *description) {
    if (validate_irq_num(irq_num) != SUCCESS) {
        add_trace("‚ùå KERNEL: Error en registro ISR - IRQ fuera de rango v√°lido");
        return ERROR_INVALID_IRQ;
    }
    
    LOCK_IDT();
    
    if (idt[irq_num].state == IRQ_STATE_EXECUTING) {
        UNLOCK_IDT();
        add_trace("‚ö†Ô∏è  KERNEL: Registro ISR fallido - IRQ actualmente en ejecuci√≥n");
        return ERROR_ISR_EXECUTING;
    }
    
    idt[irq_num].isr = isr_function;
    idt[irq_num].state = IRQ_STATE_REGISTERED;
    idt[irq_num].call_count = 0;
    idt[irq_num].total_execution_time = 0;
    strncpy(idt[irq_num].description, description, sizeof(idt[irq_num].description) - 1);
    idt[irq_num].description[sizeof(idt[irq_num].description) - 1] = '\0';
    
    UNLOCK_IDT();
    
    char trace_msg[MAX_TRACE_MSG_LEN];
    snprintf(trace_msg, sizeof(trace_msg), 
        "üìù KERNEL: ISR registrada en IDT[%d] -> Handler: \"%s\"", 
        irq_num, description);
    add_trace_with_irq(trace_msg, irq_num);
    
    snprintf(trace_msg, sizeof(trace_msg), 
        "üîó HARDWARE: IRQ %d ahora conectada al kernel - Lista para recibir se√±ales", 
        irq_num);
    add_trace_with_irq(trace_msg, irq_num);
    
    return SUCCESS;
}

// Desregistrar ISR
int unregister_isr(int irq_num) {
    if (validate_irq_num(irq_num) != SUCCESS) {
        add_trace("‚ùå KERNEL: Error en desregistro ISR - IRQ fuera de rango v√°lido");
        return ERROR_INVALID_IRQ;
    }
    
    LOCK_IDT();
    
    if (idt[irq_num].state == IRQ_STATE_EXECUTING) {
        UNLOCK_IDT();
        add_trace("‚ö†Ô∏è  KERNEL: Desregistro ISR fallido - IRQ actualmente en ejecuci√≥n");
        return ERROR_ISR_EXECUTING;
    }
    
    char old_description[MAX_DESCRIPTION_LEN];
    strncpy(old_description, idt[irq_num].description, MAX_DESCRIPTION_LEN - 1);
    old_description[MAX_DESCRIPTION_LEN - 1] = '\0';
    
    
    idt[irq_num].isr = NULL;
    idt[irq_num].state = IRQ_STATE_FREE;
    idt[irq_num].call_count = 0;
    idt[irq_num].total_execution_time = 0;
    snprintf(idt[irq_num].description, sizeof(idt[irq_num].description), 
        "IRQ %d - Disponible para asignaci√≥n", irq_num);
    
    UNLOCK_IDT();
    
    char trace_msg[MAX_TRACE_MSG_LEN];
    snprintf(trace_msg, sizeof(trace_msg), 
        "üóëÔ∏è  KERNEL: ISR removida de IDT[%d] - Era: \"%s\"", 
        irq_num, old_description);
    add_trace_with_irq(trace_msg, irq_num);
    
    snprintf(trace_msg, sizeof(trace_msg), 
        "üö´ HARDWARE: IRQ %d desconectada - Interrupciones no ser√°n procesadas", 
        irq_num);
    add_trace_with_irq(trace_msg, irq_num);
    
    return SUCCESS;
}

// Despacho de interrupciones - VERSI√ìN CORREGIDA
void dispatch_interrupt(int irq_num) {
    char trace_msg[MAX_TRACE_MSG_LEN];
    struct timespec start_time, end_time;
    void (*isr_function)(int) = NULL;
    int is_timer_irq = (irq_num == IRQ_TIMER);
    
    if (validate_irq_num(irq_num) != SUCCESS) {
        snprintf(trace_msg, sizeof(trace_msg), 
            "‚ùå HARDWARE: IRQ %d RECHAZADA - N√∫mero fuera del rango v√°lido (0-%d)", 
            irq_num, MAX_INTERRUPTS-1);
        add_trace_smart(trace_msg, -1, 0);
        return;
    }
    
    LOCK_IDT();
    
    // ‚úÖ VERIFICAR ESTADO CORRECTO
    if (idt[irq_num].state != IRQ_STATE_REGISTERED || idt[irq_num].isr == NULL) {
        UNLOCK_IDT();
        snprintf(trace_msg, sizeof(trace_msg), 
            "‚ùå KERNEL: IRQ %d SIN HANDLER - Estado: %s", 
            irq_num, get_irq_state_string(idt[irq_num].state));
        add_trace_smart(trace_msg, irq_num, is_timer_irq);
        return;
    }
    
    // ‚úÖ VERIFICAR SI YA SE EST√Å EJECUTANDO (protecci√≥n contra reentrancy)
    if (idt[irq_num].state == IRQ_STATE_EXECUTING) {
        UNLOCK_IDT();
        snprintf(trace_msg, sizeof(trace_msg), 
            "‚ö†Ô∏è  KERNEL: IRQ %d ya ejecut√°ndose - Interrupci√≥n ignorada (reentrancy)", irq_num);
        add_trace_smart(trace_msg, irq_num, is_timer_irq);
        return;
    }
    
    // Simular el proceso real de Linux
    snprintf(trace_msg, sizeof(trace_msg), 
        "üî• HARDWARE: IRQ %d disparada - L√≠nea de interrupci√≥n activada", irq_num);
    add_trace_smart(trace_msg, irq_num, is_timer_irq);
    
    snprintf(trace_msg, sizeof(trace_msg), 
        "üö® CPU: Guardando contexto actual - Registros y estado del procesador");
    add_trace_smart(trace_msg, irq_num, is_timer_irq);
    
    snprintf(trace_msg, sizeof(trace_msg), 
        "üîç KERNEL: Consultando IDT[%d] - Vector de interrupci√≥n encontrado", irq_num);
    add_trace_smart(trace_msg, irq_num, is_timer_irq);
    
    // ‚úÖ CAMBIAR ESTADO A EJECUTANDO
    idt[irq_num].state = IRQ_STATE_EXECUTING;
    idt[irq_num].call_count++;
    idt[irq_num].last_call = time(NULL);
    isr_function = idt[irq_num].isr;
    
    snprintf(trace_msg, sizeof(trace_msg), 
        "‚ö° KERNEL: Ejecutando ISR \"%s\" - Llamada #%d [Modo Kernel]", 
        idt[irq_num].description, idt[irq_num].call_count);
    
    UNLOCK_IDT();
    add_trace_smart(trace_msg, irq_num, is_timer_irq);
    
    // ‚úÖ EJECUTAR LA ISR
    clock_gettime(CLOCK_MONOTONIC, &start_time);
    
    if (isr_function) {
        isr_function(irq_num);
    }
    
    clock_gettime(CLOCK_MONOTONIC, &end_time);
    
    unsigned long execution_time = 
        (end_time.tv_sec - start_time.tv_sec) * 1000000 +
        (end_time.tv_nsec - start_time.tv_nsec) / 1000;
    
    // ‚úÖ RESTAURAR ESTADO A REGISTRADO
    LOCK_IDT();
    idt[irq_num].state = IRQ_STATE_REGISTERED;  // ‚úÖ VOLVER A REGISTRADO
    idt[irq_num].total_execution_time += execution_time;
    UNLOCK_IDT();
    
    update_stats(irq_num, execution_time);
    
    snprintf(trace_msg, sizeof(trace_msg), 
        "üîÑ CPU: Restaurando contexto - Volviendo al proceso interrumpido (%lu Œºs)", 
        execution_time);
    add_trace_smart(trace_msg, irq_num, is_timer_irq);
    
    snprintf(trace_msg, sizeof(trace_msg), 
        "‚úÖ KERNEL: IRQ %d procesada - Sistema listo para nuevas interrupciones", irq_num);
    add_trace_smart(trace_msg, irq_num, is_timer_irq);
}



// ISR del Timer del Sistema (IRQ 0)
void timer_isr(int irq_num) {
    timer_counter++;
    char trace_msg[MAX_TRACE_MSG_LEN];
    
    snprintf(trace_msg, sizeof(trace_msg), 
        "    ‚è∞ TIMER_ISR: Tick del sistema #%d - Actualizando jiffies del kernel", 
        timer_counter);
    add_trace_smart(trace_msg, irq_num, 1);
    
    snprintf(trace_msg, sizeof(trace_msg), 
        "    üìä SCHEDULER: Verificando quantum de procesos - Time slice check");
    add_trace_smart(trace_msg, irq_num, 1);
    
    usleep(ISR_SIMULATION_DELAY_US);
    
    snprintf(trace_msg, sizeof(trace_msg), 
        "    üîÑ TIMER_ISR: Completada - Sistema de tiempo actualizado");
    add_trace_smart(trace_msg, irq_num, 1);
}

// ISR del Teclado (IRQ 1)
void keyboard_isr(int irq_num) {
    char trace_msg[MAX_TRACE_MSG_LEN];
    
    snprintf(trace_msg, sizeof(trace_msg), 
        "    ‚å®Ô∏è  KEYBOARD_ISR: Leyendo scancode del controlador 8042");
    add_trace_with_irq(trace_msg, irq_num);
    
    snprintf(trace_msg, sizeof(trace_msg), 
        "    üî§ INPUT_LAYER: Traduciendo scancode a keycode");
    add_trace_with_irq(trace_msg, irq_num);
    
    snprintf(trace_msg, sizeof(trace_msg), 
        "    üì§ EVENT_QUEUE: Enviando evento de teclado a /dev/input/eventX");
    add_trace_with_irq(trace_msg, irq_num);
    
    usleep(KEYBOARD_DELAY_US);
}

// ISR personalizada de ejemplo
void custom_isr(int irq_num) {
    char trace_msg[MAX_TRACE_MSG_LEN];
    
    snprintf(trace_msg, sizeof(trace_msg), 
        "    üîß CUSTOM_ISR: Procesando interrupci√≥n de dispositivo personalizado");
    add_trace_with_irq(trace_msg, irq_num);
    
    snprintf(trace_msg, sizeof(trace_msg), 
        "    üíæ DEVICE_DRIVER: Intercambiando datos con hardware espec√≠fico");
    add_trace_with_irq(trace_msg, irq_num);
    
    snprintf(trace_msg, sizeof(trace_msg), 
        "    ‚úÖ CUSTOM_ISR: Operaci√≥n completada - Hardware listo para nuevas operaciones");
    add_trace_with_irq(trace_msg, irq_num);
    
    usleep(CUSTOM_DELAY_US);
}

// ISR de error
void error_isr(int irq_num) {
    char trace_msg[MAX_TRACE_MSG_LEN];
    snprintf(trace_msg, sizeof(trace_msg), "    ERROR ISR: Manejando error en IRQ %d", irq_num);
    add_trace_with_irq(trace_msg, irq_num);
    
    usleep(50000); // 50ms
}

// Hilo del timer autom√°tico
void* timer_thread_func(void* arg) {
    (void)arg;
    
    add_trace("üïê HARDWARE: Hilo del timer PIT (Programmable Interval Timer) iniciado");
    add_trace("‚öôÔ∏è  TIMER: Configurado para generar IRQ0 cada 3 segundos");
    
    while (system_running) {
        sleep(TIMER_INTERVAL_SEC);
        if (system_running) {
            char trace_msg[MAX_TRACE_MSG_LEN];
            snprintf(trace_msg, sizeof(trace_msg), 
                "‚è≤Ô∏è  HARDWARE: Timer PIT disparando IRQ0 - Se√±al de reloj del sistema");
            add_trace_smart(trace_msg, -1, 1);
            
            dispatch_interrupt(IRQ_TIMER);
        }
    }
    
    add_trace("üõë HARDWARE: Timer PIT detenido - Hilo del timer finalizando");
    return NULL;
}

void show_idt_status() {
    printf("\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n");
    printf("‚ïë                ESTADO ACTUAL DE LA IDT (Solo IRQs utilizadas)              ‚ïë\n");
    printf("‚ïë                       Simulando: /proc/interrupts                          ‚ïë\n");
    printf("‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£\n");
    printf("‚ïë IRQ ‚îÇ    Estado     ‚îÇ Llamadas ‚îÇ Tiempo Total (Œºs) ‚îÇ Handler Descripci√≥n    ‚ïë\n");
    printf("‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ï™‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï™‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï™‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï™‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£\n");

    int usados = 0;

    LOCK_IDT();
    for (int i = 0; i < MAX_INTERRUPTS; i++) {
        if (idt[i].call_count == 0)
            continue; // Mostrar solo si fue usada en esta ejecuci√≥n

        const char* state_str = get_irq_state_string(idt[i].state);
        const char* icon = "";

        switch (idt[i].state) {
            case IRQ_STATE_FREE:       icon = "‚ö™"; break;
            case IRQ_STATE_REGISTERED: icon = "üü¢"; break;
            case IRQ_STATE_EXECUTING:  icon = "üî¥"; break;
        }

        printf("‚ïë %s%2d ‚îÇ %-12s ‚îÇ %8d ‚îÇ %17lu ‚îÇ %-21s ‚ïë\n", 
               icon, i, state_str, idt[i].call_count, 
               idt[i].total_execution_time, idt[i].description);
        usados++;
    }
    UNLOCK_IDT();

    if (usados == 0) {
        printf("‚ïë                             ‚ö†Ô∏è  Ninguna IRQ activa                            ‚ïë\n");
    }

    printf("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n");
    printf("üü¢ = Registrada y lista  üî¥ = Ejecut√°ndose  ‚ö™ = Disponible\n");
}


// Mostrar traza reciente
void show_recent_trace() {
    printf("\n=== TRAZA RECIENTE ===\n");
    
    pthread_mutex_lock(&trace_mutex);
    int entries_to_show = (trace_index < 10) ? trace_index : 10;
    int start = (trace_index - entries_to_show + MAX_TRACE_LINES) % MAX_TRACE_LINES;
    
    for (int i = 0; i < entries_to_show; i++) {
        int idx = (start + i) % MAX_TRACE_LINES;
        if (strlen(trace_log[idx].event) > 0) {
            if (trace_log[idx].irq_num >= 0) {
                printf("[%s] [IRQ%d] %s\n", 
                       trace_log[idx].timestamp, trace_log[idx].irq_num, trace_log[idx].event);
            } else {
                printf("[%s] %s\n", trace_log[idx].timestamp, trace_log[idx].event);
            }
        }
    }
    pthread_mutex_unlock(&trace_mutex);
    printf("\n");
}

// Funci√≥n auxiliar mejorada para detectar trazas del timer
int is_timer_related_trace(const trace_entry_t *entry) {
    // Verificar por IRQ n√∫mero
    if (entry->irq_num == IRQ_TIMER) {
        return 1;
    }
    
    // Verificar por contenido del mensaje (patrones m√°s completos)
    const char* timer_patterns[] = {
        "TIMER", "Timer", "timer",
        "TICK", "Tick", "tick",
        "Hilo del timer", "timer_thread",
        "DESPACHANDO IRQ 0", "FINALIZANDO IRQ 0",
        ">>> DESPACHANDO IRQ 0", "<<< FINALIZANDO IRQ 0",
        "iniciado", "finalizando"  // Para mensajes del hilo del timer
    };
    
    int num_patterns = sizeof(timer_patterns) / sizeof(timer_patterns[0]);
    
    for (int i = 0; i < num_patterns; i++) {
        if (strstr(entry->event, timer_patterns[i]) != NULL) {
            return 1;
        }
    }
    
    return 0;
}

// Funci√≥n corregida para mostrar √∫ltima traza (excluyendo timer)
void show_last_trace() {
    printf("\n=== √öLTIMA TRAZA NO-TIMER ===\n");
    pthread_mutex_lock(&trace_mutex);
    
    int found = 0;
    int entries_checked = 0;
    
    // Calcular el n√∫mero real de entradas en el buffer circular
    int total_entries = 0;
    int start_search = trace_index;
    
    // Si trace_index es 0, empezar desde el final del buffer
    if (trace_index == 0) {
        start_search = MAX_TRACE_LINES;
    }
    
    // Buscar hacia atr√°s desde la entrada m√°s reciente
    for (int i = 0; i < MAX_TRACE_LINES && !found; i++) {
        int idx = (start_search - 1 - i + MAX_TRACE_LINES) % MAX_TRACE_LINES;
        entries_checked++;
        
        // Solo procesar entradas que tienen contenido v√°lido
        if (strlen(trace_log[idx].event) > 0) {
            total_entries++;
            
            // Verificar si es traza del timer usando la funci√≥n auxiliar
            if (!is_timer_related_trace(&trace_log[idx])) {
                printf("Entrada encontrada (posici√≥n %d desde el final):\n", i + 1);
                
                if (trace_log[idx].irq_num >= 0) {
                    printf("[%s] [IRQ%d] %s\n",
                           trace_log[idx].timestamp, 
                           trace_log[idx].irq_num, 
                           trace_log[idx].event);
                } else {
                    printf("[%s] %s\n", 
                           trace_log[idx].timestamp, 
                           trace_log[idx].event);
                }
                found = 1;
            }
        }
    }
    
    if (!found) {
        if (total_entries == 0) {
            printf("El log de trazas est√° vac√≠o\n");
        } else {
            printf("No se encontraron trazas que no sean del timer\n");
            printf("Total de entradas v√°lidas revisadas: %d\n", total_entries);
            printf("Todas las trazas recientes parecen ser del timer del sistema\n");
        }
    }
    
    pthread_mutex_unlock(&trace_mutex);
    printf("\n");
}

// Funci√≥n adicional para mostrar las √∫ltimas N trazas no-timer
void show_last_n_non_timer_traces(int n) {
    printf("\n=== √öLTIMAS %d TRAZAS NO-TIMER ===\n", n);
    pthread_mutex_lock(&trace_mutex);
    
    int found_count = 0;
    int entries_checked = 0;
    int start_search = trace_index;
    
    if (trace_index == 0) {
        start_search = MAX_TRACE_LINES;
    }
    
    printf("Buscando las √∫ltimas %d trazas que no sean del timer...\n\n", n);
    
    // Buscar hacia atr√°s desde la entrada m√°s reciente
    for (int i = 0; i < MAX_TRACE_LINES && found_count < n; i++) {
        int idx = (start_search - 1 - i + MAX_TRACE_LINES) % MAX_TRACE_LINES;
        entries_checked++;
        
        // Solo procesar entradas que tienen contenido v√°lido
        if (strlen(trace_log[idx].event) > 0) {
            // Verificar si es traza del timer
            if (!is_timer_related_trace(&trace_log[idx])) {
                found_count++;
                printf("%d. ", found_count);
                
                if (trace_log[idx].irq_num >= 0) {
                    printf("[%s] [IRQ%d] %s\n",
                           trace_log[idx].timestamp, 
                           trace_log[idx].irq_num, 
                           trace_log[idx].event);
                } else {
                    printf("[%s] %s\n", 
                           trace_log[idx].timestamp, 
                           trace_log[idx].event);
                }
            }
        }
    }
    
    if (found_count == 0) {
        printf("No se encontraron trazas que no sean del timer\n");
        printf("Entradas totales revisadas: %d\n", entries_checked);
    } else if (found_count < n) {
        printf("\nSolo se encontraron %d trazas no-timer (de %d solicitadas)\n", found_count, n);
    }
    
    pthread_mutex_unlock(&trace_mutex);
    printf("\n");
}

// Funci√≥n mejorada para debug del buffer de trazas
void debug_trace_buffer() {
    printf("\n=== DEBUG DEL BUFFER DE TRAZAS ===\n");
    pthread_mutex_lock(&trace_mutex);
    
    printf("trace_index actual: %d\n", trace_index);
    printf("MAX_TRACE_LINES: %d\n\n", MAX_TRACE_LINES);
    
    int valid_entries = 0;
    int timer_entries = 0;
    int non_timer_entries = 0;
    
    printf("An√°lisis del contenido del buffer:\n");
    for (int i = 0; i < MAX_TRACE_LINES; i++) {
        if (strlen(trace_log[i].event) > 0) {
            valid_entries++;
            if (is_timer_related_trace(&trace_log[i])) {
                timer_entries++;
            } else {
                non_timer_entries++;
            }
        }
    }
    
    printf("Entradas v√°lidas: %d\n", valid_entries);
    printf("Entradas del timer: %d\n", timer_entries);
    printf("Entradas no-timer: %d\n", non_timer_entries);
    
    // Mostrar las √∫ltimas 5 entradas con su clasificaci√≥n
    printf("\n√öltimas 5 entradas (con clasificaci√≥n):\n");
    int start = (trace_index - 5 + MAX_TRACE_LINES) % MAX_TRACE_LINES;
    for (int i = 0; i < 5; i++) {
        int idx = (start + i) % MAX_TRACE_LINES;
        if (strlen(trace_log[idx].event) > 0) {
            const char* type = is_timer_related_trace(&trace_log[idx]) ? "[TIMER]" : "[USER]";
            printf("%s [%s] %s\n", type, trace_log[idx].timestamp, trace_log[idx].event);
        }
    }
    
    pthread_mutex_unlock(&trace_mutex);
    printf("\n");
}

// Mostrar estad√≠sticas del sistema
void show_system_stats() {
    printf("\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n");
    printf("‚ïë                        ESTAD√çSTICAS DEL KERNEL                              ‚ïë\n");
    printf("‚ïë                     Simulando: /proc/stat y /proc/uptime                    ‚ïë\n");
    printf("‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£\n");
    
    time_t uptime = time(NULL) - stats.system_start_time;
    int hours = uptime / 3600;
    int minutes = (uptime % 3600) / 60;
    int seconds = uptime % 60;
    
    printf("‚ïë üïê Uptime del sistema:           %02d:%02d:%02d (%ld segundos)        ‚ïë\n", 
           hours, minutes, seconds, uptime);
    printf("‚ïë üìä Total de interrupciones:      %-10lu                           ‚ïë\n", 
           stats.total_interrupts);
    printf("‚ïë ‚è∞ Interrupciones de timer:       %-10lu (IRQ 0)                  ‚ïë\n", 
           stats.timer_interrupts);
    printf("‚ïë ‚å®Ô∏è  Interrupciones de teclado:     %-10lu (IRQ 1)                  ‚ïë\n", 
           stats.keyboard_interrupts);
    printf("‚ïë üîß Interrupciones personalizadas: %-10lu (IRQ 2-15)               ‚ïë\n", 
           stats.custom_interrupts);
    printf("‚ïë ‚ö° Tiempo promedio de ISR:        %.2f Œºs                          ‚ïë\n", 
           stats.average_response_time);
    
    // Calcular estad√≠sticas adicionales
    float irq_rate = uptime > 0 ? (float)stats.total_interrupts / uptime : 0;
    printf("‚ïë üìà Tasa de interrupciones:        %.2f IRQs/segundo                ‚ïë\n", irq_rate);
    
    printf("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n");
}

// Mostrar ayuda
void show_help() {
    printf("\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n");
    printf("‚ïë                    SIMULADOR DE INTERRUPCIONES LINUX                           ‚ïë\n");
    printf("‚ïë                        Basado en la arquitectura x86                           ‚ïë\n");
    printf("‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£\n");
    printf("‚ïë                                                                                ‚ïë\n");
    printf("‚ïë Este simulador replica el comportamiento del sistema de manejo de              ‚ïë\n");
    printf("‚ïë interrupciones del kernel de Linux, incluyendo:                                ‚ïë\n");
    printf("‚ïë                                                                                ‚ïë\n");
    printf("‚ïë üîß IDT (Interrupt Descriptor Table) - Tabla de vectores                        ‚ïë\n");
    printf("‚ïë ‚ö° ISR (Interrupt Service Routines) - Manejadores de interrupci√≥n              ‚ïë\n");
    printf("‚ïë üïê Timer PIT - Generador autom√°tico de IRQ0 cada 3 segundos                    ‚ïë\n");
    printf("‚ïë ‚å®Ô∏è  Controlador de teclado - Simulaci√≥n de entrada de usuario                  ‚ïë\n");
    printf("‚ïë üìä Sistema de trazabilidad - Log detallado de eventos                          ‚ïë\n");
    printf("‚ïë                                                                                ‚ïë\n");
    printf("‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£\n");
    printf("‚ïë                            MAPA DE INTERRUPCIONES                              ‚ïë\n");
    printf("‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£\n");
    printf("‚ïë IRQ 0  - Timer del sistema (PIT) - Autom√°tico cada 3 segundos                  ‚ïë\n");
    printf("‚ïë IRQ 1  - Controlador de teclado (8042) - Manual                                ‚ïë\n");
    printf("‚ïë IRQ 2  - Cascada del PIC secundario (reservada)                                ‚ïë\n");
    printf("‚ïë IRQ 3-15 - Dispositivos personalizados - Disponibles                           ‚ïë\n");
    printf("‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£\n");
    printf("‚ïë                              FLUJO DE INTERRUPCI√ìN                             ‚ïë\n");
    printf("‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£\n");
    printf("‚ïë 1. üî• Hardware genera se√±al de interrupci√≥n                                    ‚ïë\n");
    printf("‚ïë 2. üö® CPU guarda contexto actual (registros)                                   ‚ïë\n");
    printf("‚ïë 3. üîç Kernel consulta IDT por el vector correspondiente                        ‚ïë\n");
    printf("‚ïë 4. ‚ö° Se ejecuta la ISR en modo kernel                                         ‚ïë\n");
    printf("‚ïë 5. üîÑ CPU restaura contexto y contin√∫a ejecuci√≥n                               ‚ïë\n");
    printf("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n");
}

// Funci√≥n adicional para debugging - mostrar todos los estados
void debug_all_irq_states() {
    printf("\n=== DEBUG: TODOS LOS ESTADOS DE IRQ ===\n");
    
    LOCK_IDT();
    
    int free_count = 0;
    int registered_count = 0;
    int executing_count = 0;
    
    for (int i = 0; i < MAX_INTERRUPTS; i++) {
        const char* state_str = get_irq_state_string(idt[i].state);
        const char* icon = "";
        
        switch (idt[i].state) {
            case IRQ_STATE_FREE:       icon = "‚ö™"; free_count++; break;
            case IRQ_STATE_REGISTERED: icon = "üü¢"; registered_count++; break;
            case IRQ_STATE_EXECUTING:  icon = "üî¥"; executing_count++; break;
        }
        
        printf("IRQ%2d: %s %-12s ‚îÇ Calls: %3d ‚îÇ %s\n", 
               i, icon, state_str, idt[i].call_count, 
               (idt[i].call_count > 0) ? idt[i].description : "Sin actividad");
    }
    
    UNLOCK_IDT();
    
    printf("\nüìä RESUMEN DE ESTADOS:\n");
    printf("  üü¢ Registradas: %d\n", registered_count);
    printf("  üî¥ Ejecut√°ndose: %d\n", executing_count);
    printf("  ‚ö™ Libres: %d\n", free_count);
    printf("  üìã Total: %d\n", MAX_INTERRUPTS);
    printf("\n");
}

// Men√∫ interactivo
void show_menu() {
    printf("\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n");
    printf("‚ïë                    üêß SIMULADOR KERNEL LINUX - INTERRUPCIONES üêß             ‚ïë\n");
    printf("‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£\n");
    printf("‚ïë  1. üî• Generar interrupci√≥n manual     ‚îÇ  6. üóëÔ∏è  Desregistrar ISR            ‚ïë\n");
    printf("‚ïë  2. üìù Registrar ISR personalizada     ‚îÇ  7. üìä Estad√≠sticas del sistema     ‚ïë\n");
    printf("‚ïë  3. üéØ Estado de la IDT                ‚îÇ  8. ‚öôÔ∏è  Configurar logging          ‚ïë\n");
    printf("‚ïë  4. üìú Mostrar traza reciente          ‚îÇ  9. ‚ùì Ayuda del simulador          ‚ïë\n");
    printf("‚ïë  5. üß™ Suite de pruebas m√∫ltiples      ‚îÇ  0. üö™ Salir del programa           ‚ïë\n");
    printf("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n");
    printf("Seleccione una opci√≥n [0-9]: ");
    fflush(stdout);
}

void logging_submenu() {
    int option;
    
    while (1) {
        printf("\n=== CONFIGURACI√ìN DE LOGGING ===\n");
        printf("Estado actual: ");
        
        switch (current_log_level) {
            case LOG_LEVEL_SILENT:
                printf("SILENCIOSO");
                break;
            case LOG_LEVEL_USER_ONLY:
                printf("SOLO USUARIO (Timer logs: %s)", show_timer_logs ? "ON" : "OFF");
                break;
            case LOG_LEVEL_VERBOSE:
                printf("VERBOSE");
                break;
        }
        
        printf("\n\n1. Modo silencioso (solo guardar en historial)\n");
        printf("2. Modo usuario (solo acciones del usuario)\n");
        printf("3. Modo verbose (mostrar todo)\n");
        printf("4. Toggle logs del timer (actual: %s)\n", show_timer_logs ? "ON" : "OFF");
        printf("5. Mostrar logs del timer en tiempo real por 30 segundos\n");
        printf("0. Volver al men√∫ principal\n");
        printf("Seleccione una opci√≥n: ");
        fflush(stdout);
        
        option = get_valid_input(0, 5);
        
        switch (option) {
            case 1:
                set_log_level(LOG_LEVEL_SILENT);
                break;
            case 2:
                set_log_level(LOG_LEVEL_USER_ONLY);
                break;
            case 3:
                set_log_level(LOG_LEVEL_VERBOSE);
                break;
            case 4:
                toggle_timer_logs();
                break;
            case 5:
                printf("Mostrando logs del timer por 30 segundos...\n");
                int old_show_timer = show_timer_logs;
                log_level_t old_level = current_log_level;
                show_timer_logs = 1;
                current_log_level = LOG_LEVEL_USER_ONLY;
                sleep(30);
                show_timer_logs = old_show_timer;
                current_log_level = old_level;
                printf("Volviendo a la configuraci√≥n anterior.\n");
                break;
            case 0:
                return;
        }
    }
}


void test_concurrent_interrupts() {
    printf("Probando interrupciones concurrentes...\n");
    
    // Generar m√∫ltiples interrupciones r√°pidamente
    for (int i = 0; i < 5; i++) {
        dispatch_interrupt(IRQ_TIMER);
        dispatch_interrupt(IRQ_KEYBOARD);
        usleep(100000); // 100ms
    }
    
    printf("Prueba de concurrencia completada.\n");
}

void test_stress_interrupts() {
    printf("Ejecutando prueba de stress...\n");
    
    for (int i = 0; i < 20; i++) {
        dispatch_interrupt(i % MAX_INTERRUPTS);
        usleep(50000); // 50ms
    }
    
    printf("Prueba de stress completada.\n");
}

// Funci√≥n para limpiar entrada inv√°lida del buffer
void clear_input_buffer() {
    int c;
    while ((c = getchar()) != '\n' && c != EOF);
}

// Funci√≥n para obtener entrada num√©rica v√°lida
int get_valid_input(int min, int max) {
    int input;
    char buffer[256];
    char *endptr;
    
    while (1) {
        memset(buffer, 0, sizeof(buffer));
        
        if (fgets(buffer, sizeof(buffer), stdin) == NULL) {
            printf("Error leyendo entrada. Intente de nuevo: ");
            continue;
        }
        
        size_t len = strlen(buffer);
        if (len > 0 && buffer[len-1] == '\n') {
            buffer[len-1] = '\0';
        }
        
        char *trimmed = buffer;
        while (*trimmed == ' ' || *trimmed == '\t') {
            trimmed++;
        }
        
        if (*trimmed == '\0') {
            printf("Entrada inv√°lida. Ingrese un n√∫mero entre %d y %d: ", min, max);
            continue;
        }
        
        input = (int)strtol(trimmed, &endptr, 10);
        
        if (*endptr != '\0') {
            printf("Entrada inv√°lida. Ingrese un n√∫mero entre %d y %d: ", min, max);
            continue;
        }
        
        if (input >= min && input <= max) {
            return input;
        }
        
        printf("N√∫mero fuera de rango. Ingrese un n√∫mero entre %d y %d: ", min, max);
    }
}

// Funci√≥n simple para esperar Enter
void wait_for_enter() {
    printf("\nPresione Enter para continuar...");
    fflush(stdout);
    
    char buffer[10];
    fgets(buffer, sizeof(buffer), stdin);
}

void improved_main_initialization() {
    printf("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n");
    printf("‚ïë                    üöÄ INICIANDO SIMULADOR KERNEL LINUX                      ‚ïë\n");
    printf("‚ïë                          Versi√≥n 2.0 - Modo Educativo                       ‚ïë\n");
    printf("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n");
    
    printf("\nüîß FASE DE INICIALIZACI√ìN DEL KERNEL:\n");
    printf("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n");
    
    // Inicializar sistema
    printf("üìã Inicializando IDT (Interrupt Descriptor Table)...\n");
    fflush(stdout);
    init_idt();
    
    printf("üìà Configurando sistema de estad√≠sticas...\n");
    fflush(stdout);
    init_system_stats();
    
    // Registrar ISRs predeterminadas
    printf("‚è∞ Registrando handler del Timer PIT (IRQ0)...\n");
    fflush(stdout);
    register_isr(IRQ_TIMER, timer_isr, "Timer PIT - Reloj del sistema");
    
    printf("‚å®Ô∏è  Registrando handler del teclado (IRQ1)...\n");
    fflush(stdout);
    register_isr(IRQ_KEYBOARD, keyboard_isr, "Controlador de teclado 8042");
    
    // Iniciar hilo del timer
    printf("üïê Iniciando hilo del timer autom√°tico...\n");
    fflush(stdout);
    if (pthread_create(&timer_thread, NULL, timer_thread_func, NULL) != 0) {
        add_trace("‚ùå KERNEL PANIC: Error creando hilo del timer");
        printf("‚ùå ERROR CR√çTICO: No se pudo iniciar el timer del sistema\n");
        return;
    }
    
    printf("\n‚úÖ KERNEL INICIADO CORRECTAMENTE\n");
    printf("üéØ El sistema est√° listo para procesar interrupciones\n");
    printf("‚è∞ Timer autom√°tico generar√° IRQ0 cada 3 segundos\n\n");
    
    // Peque√±a pausa para que el usuario vea la inicializaci√≥n
    printf("Presione Enter para continuar al men√∫ principal...");
    fflush(stdout);
    wait_for_enter();
}

// Funci√≥n para guardar el estado actual de la IDT
void save_idt_state(irq_descriptor_t *backup) {
    LOCK_IDT();
    
    for (int i = 0; i < MAX_INTERRUPTS; i++) {
        backup[i].isr = idt[i].isr;
        backup[i].state = idt[i].state;
        backup[i].call_count = idt[i].call_count;
        backup[i].last_call = idt[i].last_call;
        backup[i].total_execution_time = idt[i].total_execution_time;
        strncpy(backup[i].description, idt[i].description, sizeof(backup[i].description) - 1);
        backup[i].description[sizeof(backup[i].description) - 1] = '\0';
    }
    
    UNLOCK_IDT();
    
    add_trace("üíæ KERNEL: Estado de IDT guardado para respaldo");
}

// Funci√≥n para restaurar el estado previo de la IDT
void restore_idt_state(const irq_descriptor_t *backup) {
    LOCK_IDT();
    
    for (int i = 0; i < MAX_INTERRUPTS; i++) {
        idt[i].isr = backup[i].isr;
        idt[i].state = backup[i].state;
        idt[i].call_count = backup[i].call_count;
        idt[i].last_call = backup[i].last_call;
        idt[i].total_execution_time = backup[i].total_execution_time;
        strncpy(idt[i].description, backup[i].description, sizeof(idt[i].description) - 1);
        idt[i].description[sizeof(idt[i].description) - 1] = '\0';
    }
    
    UNLOCK_IDT();
    
    add_trace("üßπ KERNEL: Estado de IDT restaurado tras pruebas");
}

// Funci√≥n para limpiar ISRs de prueba (mantiene solo las del sistema)
void cleanup_test_isrs(void) {
    int cleaned_count = 0;
    
    LOCK_IDT();
    
    for (int i = 0; i < MAX_INTERRUPTS; i++) {
        // Preservar ISRs del sistema (IRQ0 Timer e IRQ1 Keyboard)
        if (i == IRQ_TIMER || i == IRQ_KEYBOARD) {
            continue;
        }
        
        // Limpiar cualquier otra ISR registrada
        if (idt[i].state != IRQ_STATE_FREE && idt[i].isr != NULL) {
            idt[i].isr = NULL;
            idt[i].state = IRQ_STATE_FREE;
            idt[i].call_count = 0;
            idt[i].total_execution_time = 0;
            snprintf(idt[i].description, sizeof(idt[i].description), 
                "IRQ %d - Disponible para asignaci√≥n", i);
            cleaned_count++;
        }
    }
    
    UNLOCK_IDT();
    
    char trace_msg[MAX_TRACE_MSG_LEN];
    snprintf(trace_msg, sizeof(trace_msg), 
        "üßº KERNEL: %d ISRs de prueba limpiadas - Solo ISRs del sistema preservadas", 
        cleaned_count);
    add_trace(trace_msg);
}
const char *get_irq_description(int irq_num) {
    for (size_t i = 0; i < sizeof(irq_table) / sizeof(irq_table[0]); ++i) {
        if (irq_table[i].irq == irq_num)
            return irq_table[i].desc;
    }
    return "Desconocido";
}

// Versi√≥n modificada de run_interrupt_test_suite()
void run_interrupt_test_suite(void) {
    printf("\nüß™ INICIANDO SUITE DE PRUEBAS DE INTERRUPCIONES ALEATORIAS\n");
    printf("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n");

    // Guardar estado actual de la IDT
    irq_descriptor_t idt_backup[MAX_INTERRUPTS];
    save_idt_state(idt_backup);

    // 1) Registrar todos los ISRs de la tabla (excluyendo IRQ0)
    printf("üìù Fase 1: Registrando controladores de interrupci√≥n...\n");
    for (size_t i = 0; i < sizeof(irq_table) / sizeof(irq_table[0]); ++i) {
        if (irq_table[i].irq == IRQ_TIMER) continue; // Evita IRQ0
        register_isr(irq_table[i].irq, custom_isr, irq_table[i].desc);
    }

    // 2) Preparar generador de n√∫meros aleatorios
    struct timeval tv;
    gettimeofday(&tv, NULL);
    unsigned int seed = (unsigned int)(tv.tv_sec ^ tv.tv_usec ^ getpid());
    srand(seed);
    printf("üî¢ Semilla aleatoria usada: %u\n", seed);

    // 3) Calcular cu√°ntas interrupciones se disparar√°n (entre 3 y 8)
    int total_events = 3 + rand() % 6; // 3, 4, 5, 6, 7 o 8
    printf("\nüî• Fase 2: Generando %d interrupciones aleatorias...\n\n", total_events);

    // 4) CORRECCI√ìN PRINCIPAL: Disparar interrupciones seleccionando aleatoriamente de la tabla
    for (int ev = 1; ev <= total_events; ++ev) {
        // AQU√ç EST√Å EL PROBLEMA CORREGIDO:
        // Seleccionar un √≠ndice aleatorio directamente de irq_table
        int table_idx = rand() % (sizeof(irq_table) / sizeof(irq_table[0]));
        int irq_num = irq_table[table_idx].irq;
        const char *irq_desc = irq_table[table_idx].desc;

        printf("\nüîî Evento %d/%d ‚Üí IRQ%d: %s\n",
               ev, total_events, irq_num, irq_desc);
        
        dispatch_interrupt(irq_num);
        
        // Esperar entre 100 ms y 800 ms para emular tiempos reales variables
        useconds_t delay_us = 100000 + (rand() % 701000); // 100,000‚Äì800,999 ¬µs
        usleep(delay_us);
    }

    // ‚úÖ Mostrar estado modificado de la IDT antes de limpiar
    printf("\nüìã Estado de la IDT tras ejecutar las interrupciones de prueba:\n");
    show_idt_status();

    // ‚úÖ Restaurar estado original
    restore_idt_state(idt_backup);
    // Mostrar estad√≠sticas finales
    printf("\nüìä Estad√≠sticas de la suite de pruebas:\n");

    printf("\nüéâ SUITE DE PRUEBAS COMPLETADA CON √âXITO\n");
    printf("üìä Revise los logs para las estad√≠sticas de latencia y manejo\n");
    printf("üîÑ Ejecute de nuevo para obtener una secuencia diferente\n");
}

// Funci√≥n adicional para pruebas m√°s avanzadas
void run_advanced_interrupt_test_suite(void) {
    printf("\nüöÄ INICIANDO SUITE DE PRUEBAS AVANZADAS\n");
    printf("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n");

    // Guardar estado actual de la IDT
    irq_descriptor_t idt_backup[MAX_INTERRUPTS];
    save_idt_state(idt_backup);

    // Registrar ISRs
    printf("üìù Registrando controladores...\n");
    for (size_t i = 0; i < sizeof(irq_table) / sizeof(irq_table[0]); ++i) {
        if (irq_table[i].irq == IRQ_TIMER) continue;
        register_isr(irq_table[i].irq, custom_isr, irq_table[i].desc);
    }

    // Preparar aleatoriedad
    struct timeval tv;
    gettimeofday(&tv, NULL);
    unsigned int seed = (unsigned int)(tv.tv_sec ^ tv.tv_usec ^ getpid());
    srand(seed);
    printf("üî¢ Semilla aleatoria: %u\n", seed);

    // Prueba 1: R√°faga de interrupciones
    printf("\nüî• Prueba 1: R√°faga de interrupciones r√°pidas\n");
    int burst_count = 2 + rand() % 4; // 2-5 interrupciones
    for (int i = 0; i < burst_count; i++) {
        int idx = rand() % (sizeof(irq_table) / sizeof(irq_table[0]));
        printf("  üí• R√°faga %d ‚Üí IRQ%d: %s\n", i+1, irq_table[idx].irq, irq_table[idx].desc);
        dispatch_interrupt(irq_table[idx].irq);
        usleep(50000); // 50ms entre interrupciones
    }

    sleep(1); // Pausa entre pruebas

    // Prueba 2: Interrupciones con patrones variables
    printf("\nüéØ Prueba 2: Patr√≥n de interrupciones variables\n");
    int pattern_count = 3 + rand() % 5; // 3-7 interrupciones
    for (int i = 0; i < pattern_count; i++) {
        int idx = rand() % (sizeof(irq_table) / sizeof(irq_table[0]));
        printf("  üé™ Patr√≥n %d ‚Üí IRQ%d: %s\n", i+1, irq_table[idx].irq, irq_table[idx].desc);
        dispatch_interrupt(irq_table[idx].irq);
        
        // Delay variable: corto, medio o largo
        int delay_type = rand() % 3;
        useconds_t delay = (delay_type == 0) ? 100000 : 
                          (delay_type == 1) ? 300000 : 600000;
        usleep(delay);
    }
    // ‚úÖ Mostrar estado modificado de la IDT antes de limpiar
    printf("\nüìã Estado de la IDT tras ejecutar las interrupciones de prueba:\n");
    show_idt_status();

    // ‚úÖ Restaurar estado original
    restore_idt_state(idt_backup);
    printf("\nüéâ SUITE AVANZADA COMPLETADA\n");
}



// Funci√≥n principal
int main() {
    int option, irq_num;
    
    improved_main_initialization();
    
    // Bucle principal del men√∫
   while (system_running) {
    show_menu();
    option = get_valid_input(0, 9);
    printf("\n");
    
    switch (option) {
        case 1:
            printf("Ingrese el n√∫mero de IRQ (0-%d): ", MAX_INTERRUPTS - 1);
            fflush(stdout);
            irq_num = get_valid_input(0, MAX_INTERRUPTS - 1);
            printf("Despachando IRQ %d...\n", irq_num);
            dispatch_interrupt(irq_num);
            
            // Mostrar √∫ltima traza para explicar el proceso de interrupci√≥n
            printf("\n--- Proceso de interrupci√≥n ejecutado ---\n");
            wait_for_enter();
            break;
            
        case 2:
            printf("Ingrese el n√∫mero de IRQ para registrar ISR personalizada (2-%d): ", MAX_INTERRUPTS - 1);
            fflush(stdout);
            irq_num = get_valid_input(2, MAX_INTERRUPTS - 1);
            char desc[MAX_DESCRIPTION_LEN];
            snprintf(desc, sizeof(desc), "ISR Personalizada %d", irq_num);
            printf("Registrando ISR para IRQ %d...\n", irq_num);
            
            if (register_isr(irq_num, custom_isr, desc) == SUCCESS) {
                printf("‚úì ISR registrada exitosamente para IRQ %d.\n", irq_num);
                
                // Mostrar √∫ltima traza para confirmar el registro
                printf("\n--- Registro de ISR completado ---\n");
                show_last_trace();
            } else {
                printf("‚úó Error al registrar ISR para IRQ %d.\n", irq_num);
            }
            wait_for_enter();
            break;
            
        case 3:
            printf("Mostrando estado actual de la IDT...\n");
            show_idt_status();
            wait_for_enter();
            break;
            
        case 4:
            printf("Mostrando traza reciente...\n");
            show_recent_trace();
            wait_for_enter();
            break;
            
        case 5:
            printf("Ejecutando suite de pruebas de interrupciones...\n");
            run_interrupt_test_suite();
            printf("‚úì Suite de pruebas completada.\n");


            wait_for_enter();
            break;
            
        case 6:
            printf("Ingrese el n√∫mero de IRQ a desregistrar (0-%d): ", MAX_INTERRUPTS - 1);
            fflush(stdout);
            irq_num = get_valid_input(0, MAX_INTERRUPTS - 1);
            printf("Desregistrando ISR para IRQ %d...\n", irq_num);
            
            if (unregister_isr(irq_num) == SUCCESS) {
                printf("‚úì ISR desregistrada exitosamente para IRQ %d.\n", irq_num);
                
                // Mostrar √∫ltima traza para confirmar la desregistraci√≥n
                printf("\n--- Desregistro de ISR completado ---\n");
                show_last_trace();
            } else {
                printf("‚úó Error al desregistrar ISR para IRQ %d.\n", irq_num);
            }
            wait_for_enter();
            break;
            
        case 7:
            printf("Mostrando estad√≠sticas del sistema...\n");
            show_system_stats();
            wait_for_enter();
            break;
            
        case 8:
            printf("Configurando sistema de logging...\n");
            logging_submenu();
            break;
            
        case 9:
            printf("Mostrando ayuda...\n");
            show_help();
            wait_for_enter();
            break;
            
        case 0:
            printf("Finalizando simulador...\n");
            system_running = 0;
            break;
            
        default:
            printf("Opci√≥n inv√°lida: %d\n", option);
            printf("Por favor, seleccione una opci√≥n v√°lida (0-8).\n");
            wait_for_enter();
            break;
    }
    
    if (system_running) {
        printf("\n");
    }
}
    
    // Limpiar recursos
    add_trace("Finalizando sistema de interrupciones");
    
    // Esperar a que termine el hilo del timer
    if (pthread_join(timer_thread, NULL) != 0) {
        printf("Advertencia: Error al finalizar hilo del timer\n");
    }
    
    pthread_mutex_destroy(&idt_mutex);
    pthread_mutex_destroy(&trace_mutex);
    
    printf("Simulador finalizado correctamente.\n");
    return SUCCESS;
}